import * as dgram from 'dgram';
import * as events from 'events';
import { newDeferredPromise } from '../helpers.js';
export class UDPServer extends events.EventEmitter {
    constructor(port, address, logger, type = 'udp4') {
        super();
        this.port = port;
        this.address = address;
        this.logger = logger;
        this.timeout = {};
        this.server = dgram.createSocket(type);
    }
    sendToClient(msg, port, address, callback, expectAcknowledgment = true) {
        let retried = 0;
        const sendResponse = () => {
            if (retried > 0) {
                this.logger.warn('UDPServer', `no confirmation of last message from ${address}:${port}, re-sending response... (bytes: ${msg.length}, try: ${retried}/${UDPServer.MAX_RETRIES})`);
            }
            // send message to client
            this.server.send(msg, 0, msg.length, port, address, callback);
            // retry up to MAX_RETRIES to send this message,
            // we automatically retry if there is no confirmation (=any incoming message from client)
            // if expectAcknowledgment is false (e.g. Access-Accept or Access-Reject), we do not retry
            const identifierForRetry = `${address}:${port}`;
            if (expectAcknowledgment && retried < UDPServer.MAX_RETRIES) {
                this.timeout[identifierForRetry] = setTimeout(() => sendResponse(), 1600 * (retried + 1));
            }
            retried += 1;
        };
        sendResponse();
    }
    async start() {
        const startServer = newDeferredPromise();
        this.server.on('listening', () => {
            const address = this.server.address();
            this.logger.log('UDPServer', `radius server listening ${address.address}:${address.port}`);
            this.setupListeners();
            startServer.resolve();
        });
        this.server.on('message', (_msg, rinfo) => {
            // message retrieved, reset timeout handler
            const identifierForRetry = `${rinfo.address}:${rinfo.port}`;
            if (this.timeout[identifierForRetry]) {
                clearTimeout(this.timeout[identifierForRetry]);
            }
        });
        this.server.bind(this.port, this.address);
        return startServer.promise;
    }
    setupListeners() {
        this.server.on('message', (message, rinfo) => this.emit('message', message, rinfo));
    }
}
UDPServer.MAX_RETRIES = 3;
//# sourceMappingURL=UDPServer.js.map