import ldapjs from 'ldapjs';
import * as fs from 'fs';
const usernameFields = ['posixUid', 'mail'];
export class GoogleLDAPAuth {
    constructor(config, logger) {
        this.base = config.base;
        this.searchBase = config.searchBase || `ou=users,${this.base}`;
        this.logger = logger.context('GoogleLDAPAuth');
        const tlsOptions = {
            key: fs.readFileSync(config.tls.keyFile),
            cert: fs.readFileSync(config.tls.certFile),
            servername: 'ldap.google.com',
            ...config.tlsOptions,
        };
        this.config = {
            url: 'ldaps://ldap.google.com:636',
            tlsOptions,
        };
        this.dnsFetch = this.fetchDNs();
        this.dnsFetch.catch((err) => {
            this.logger.error('fatal error google ldap auth, cannot fetch DNs', err);
        });
    }
    async fetchDNs() {
        try {
            const dns = {};
            const dnResult = await new Promise((resolve, reject) => {
                const ldapDNClient = ldapjs.createClient(this.config).on('error', (error) => {
                    this.logger.error('Error in ldap', error);
                    reject(error);
                });
                ldapDNClient.search(this.searchBase, {
                    scope: 'sub',
                    // only select required attributes
                    attributes: [...usernameFields, 'dn'],
                }, (err, res) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    res.on('searchEntry', (entry) => {
                        // this.logger.debug('entry: ' + JSON.stringify(entry.object));
                        usernameFields.forEach((field) => {
                            const index = entry.object[field];
                            dns[index] = entry.object.dn;
                        });
                    });
                    res.on('searchReference', (referral) => {
                        this.logger.debug(`referral: ${referral.uris.join()}`);
                    });
                    res.on('error', (ldapErr) => {
                        this.logger.error(`error: ${JSON.stringify(ldapErr)}`);
                        reject(ldapErr);
                    });
                    res.on('end', (result) => {
                        this.logger.debug(`ldap status: ${result?.status}`);
                        // this.logger.debug('allValidDNsCache', this.allValidDNsCache);
                        resolve(dns);
                    });
                });
            });
            setTimeout(() => {
                this.dnsFetch = undefined;
            }, 60 * 60 * 12 * 1000); // reset cache after 12h
            return dnResult;
        }
        catch (err) {
            console.error('dns fetch err', err);
            // retry dns fetch next time
            this.dnsFetch = undefined;
            throw err;
        }
    }
    async authenticate(username, password, count = 0, forceFetching = false) {
        /*
         just a test for super slow google responses
        await new Promise((resolve, reject) => {
            setTimeout(resolve, 10000); // wait 10 seconds
        })
         */
        let dnsFetched = false;
        if (!this.dnsFetch || forceFetching) {
            this.logger.debug('fetching dns');
            this.dnsFetch = this.fetchDNs();
            dnsFetched = true;
        }
        const resolvedDNs = await this.dnsFetch;
        if (count > 5) {
            throw new Error('Failed to authenticate with LDAP!');
        }
        // const dn = ;
        const dn = resolvedDNs[username];
        if (!dn) {
            if (!dnsFetched && !forceFetching) {
                return this.authenticate(username, password, count, true);
            }
            // this.logger.this.logger.debug('this.allValidDNsCache', this.allValidDNsCache);
            this.logger.error(`invalid username, not found in DN: ${username}`); // , this.allValidDNsCache);
            return false;
        }
        const authResult = await new Promise((resolve, reject) => {
            // we never unbding a client, therefore create a new client every time
            const authClient = ldapjs.createClient(this.config);
            authClient.bind(dn, password, (err, res) => {
                if (err) {
                    if (err && err.stack && err.stack.includes(`ldap.google.com closed`)) {
                        count += 1;
                        // wait 1 second to give the ldap error handler time to reconnect
                        setTimeout(() => resolve(this.authenticate(dn, password)), 2000);
                        return;
                    }
                    resolve(false);
                    // this.logger.error('ldap error', err);
                    // reject(err);
                }
                if (res)
                    resolve(res);
                else
                    reject();
                authClient.unbind();
            });
        });
        return authResult;
    }
}
//# sourceMappingURL=GoogleLDAPAuth.js.map