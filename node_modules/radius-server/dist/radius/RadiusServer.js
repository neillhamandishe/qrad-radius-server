import radius from 'radius';
import { PacketResponseCode } from '../interfaces/PacketHandler.js';
import { PacketHandler } from './PacketHandler.js';
import { UDPServer } from '../server/UDPServer.js';
import { startTLSServer } from '../tls/crypt.js';
import { ConsoleLogger, LogLevel } from '../logger/ConsoleLogger.js';
function hasLogger(options) {
    return !!options.logger;
}
function hasLogLevel(options) {
    return options.logLevel !== undefined;
}
export class RadiusServer extends UDPServer {
    constructor(options) {
        super(options.port || 1812, options.address || '0.0.0.0', (hasLogger(options) && options.logger) ||
            new ConsoleLogger((hasLogLevel(options) && options.logLevel) || LogLevel.Log));
        this.options = options;
        this.packetHandler = new PacketHandler(options.authentication, options.tlsOptions, this.logger, options.secret, options.vlan);
        this.installListeners();
    }
    async start() {
        // test node version
        const testSocket = startTLSServer(this.options.tlsOptions, this.logger);
        if (typeof testSocket.tls.exportKeyingMaterial !== 'function') {
            this.logger.error('RadiusServer', `UNSUPPORTED NODE VERSION (${process.version}) FOUND!!`);
            this.logger.log('RadiusServer', 'min version supported is node js 14. run "sudo npx n 14"');
            process.exit(-1);
        }
        return super.start();
    }
    installListeners() {
        super.on('message', async (msg, rinfo) => {
            try {
                const response = await this.handleMessage(msg);
                if (response) {
                    super.sendToClient(response.data, rinfo.port, rinfo.address, (err, _bytes) => {
                        if (err) {
                            this.logger.log('Error sending response to ', rinfo);
                        }
                    }, response.expectAcknowledgment);
                }
            }
            catch (err) {
                this.logger.error('RadiusServer', 'err', err);
            }
        });
    }
    async handleMessage(msg) {
        const packet = radius.decode({ packet: msg, secret: this.options.secret });
        if (packet.code !== 'Access-Request') {
            this.logger.error('unknown packet type: ', packet.code);
            return undefined;
        }
        const response = await this.packetHandler.handlePacket(packet);
        // still no response, we are done here
        if (!response || !response.code) {
            return undefined;
        }
        // all fine, return radius encoded response
        return {
            data: radius.encode_response({
                packet,
                code: response.code,
                secret: this.options.secret,
                attributes: response.attributes,
            }),
            // if message is accept or reject, we conside this as final message
            // this means we do not expect a reponse from the client again (acknowledgement for package)
            expectAcknowledgment: response.code === PacketResponseCode.AccessChallenge,
        };
    }
}
//# sourceMappingURL=RadiusServer.js.map